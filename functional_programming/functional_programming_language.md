# 함수형 프로그래밍 언어

## 함수형 프로그래밍은 ...이 아니다
- `map`이나 `reduce`가 아니다.

모든 함수형 언어에서 이 함수들을 보게 될 수 있지만, 이 함수가 존재함으로 인해서 어떠한 언어가 함수형이 되는 것은 아니다. 시퀀스 자료를 처리하는 과정에서 부작용을 걷어내려고 노력하다 보면 얻게 되는 함수들일 뿐이다.

- 람다 함수가 아니다.

함수형 언어에서는 또한 일급 함수(First-Class Function)가 있을 것이다. 람다 함수 역시 부작용을 회피하기 위한 언어를 만들다보면 자연스럽게 얻게 되는 것이다. FP를 가능하게 하는 것이나 핵심요소는 아니다.

- 타입에 관한 것이 아니다.

정적 타입 검사는 매우 유용한 도구이지만 FP의 전제 조건이 아니다. *cf) Lisp은 가장 오래된 함수형 프로그래밍 언어이자 가장 오래된 동적 언어이기도 하다.*

정적 타입이 매우 유용할 수는 있다. 하스켈은 타입 시스템을 사용해서 부작용을 공격한 케이스이다. 하지만 정적 타입이냐 아니냐가 함수형 언어이냐 아니냐를 결정하지는 못한다.

**함수형은 부작용에 관한 것이다.**


## 각 언어 차원에서 함수형 프로그래밍을 바라보자면?

1. **Javascript**

자바스크립트는 함수형 언어가 아니다. 함수형 언어는 우리가 부작용을 제거할 수 있는 곳에서는 제거를 돕고, 그럴 수 없는 곳에서는 통제할 수 있게 도와준다. 자바스크립트는 이 기준을 충족하지 않는다. 오히려 자바스크립트가 적극적으로 부작용을 **장려**하는 것을 쉽게 찾을 수 있다.

쉽게 찾을 수 있는 것이 `this`이다. `this`는 모든 함수의 숨겨진 입력이다. 전문가라고 할 만한 자바스크립트 프로그래머들조차 `this`의 참조 대상을 추적하는데 어려움을 겪는다. 함수형 관점에서 보자면 어디서나 마법처럼 접근 가능하다는 사실이 **설계 결함의 징후**(Design Smell)이다.

2. **Java**

자바는 명백하게 함수형 언어가 아니다. 오히려 자바는 함수형 프로그래밍과 정반대 지점에 있다. 자바의 핵심 설계 원칙에서 말하는 것이 바로 '**코드는 지역화된 부작용들(객체의 지역 상태를 변경하거나 지역 상태에 의존하는 메소드들)로 조직화되어야 한다.**' 이다.

만약 자바에서 부작용 없는 코드를 작성한다면 static 키워드로 넘칠 것이고 그것은 '나쁜 프로그래머가 짠 코드'라고 불리게 될 것이다. 자바는 부작용을 국소화하는 것을 좋은 코드라고 보며, FP는 부작용을 악으로 간주한다.

즉, **부작용을 대하는 관점이 다르다.** OO의 관점은 '부작용을 객체라는 경계 안에 가두어라' 이며, FP의 관점은 '부작용을 제거하라'이다.

3. **Haskell**

하스켈은 부작용을 정말 싫어하며 그것을 통제하는데 엄청난 노력을 쏟고 있다.

하스켈이 부작용과 싸우는 흥미로운 방법 중 하나는 타입이다. 하스켈은 모든 부작용을 타입 시스템으로 밀어 올린다. 예를 들어, `getPerson` 함수가 있다고 가정해보자.
```haskell
getPerson :: UUID -> Database Person
```

'`UUID`를 받고 `Database` 컨텍스트에서 `Person`을 반환한다.' 정도로 읽을 수 있다. 하스켈 함수의 타입 시그니쳐만 보고도 어떤 부작용이 관련되는지 확실히 알 수가 있다.

```haskell
formatName :: Person -> String
```

이 함수가 `Person`을 받아서 `String`을 반환한다는 것을 알 수 있다. 만일 이 함수에 부작용이 있다면 타입 시그니처에 분명히 표시되어 우리가 알 수 있다.

```haskell
formatName :: Person -> Database String
```

여기서 시그니처는 `formatName` 함수가 데이터베이스 관련 부작용을 포함한다는 것을 알려준다. 자연스럽게 이런 생각에 이를 수 있게 된다. '왜 `formatName`같은 함수가 데이터베이스를 필요로 하지?' 이상함이 느껴진다.

즉, **함수의 시그니처만 보고도 설계 문제점을 볼 수 있다.** 코드를 들여다볼 필요가 없이 개요만 보고서 코드의 냄새를 맡을 수 있다.

```java
public String formatName(Person person) {...}
```

자바의 시그니처이다. 함수의 몸체를 들여다보지 않고서 우리는 부작용의 유무를 알 수 있는 길이 없다. 실제 어떤 일이 일어날 지 타입 시그니처로 알 수 있는 것이 거의 없고, 따라서 함수의 표면 아래에 있는 것들이 무엇인지도 알 수 없다.

4. **Python**

자바에서의 근본적인 부작용 패턴이다.
```java
public String getName() {
    return this.name;
}
```

이 함수를 순수하게 만드는 방법은 숨겨진 입력인 `this`를 인자에 추가하는 것을 통해 표면 위로 끌어올리면 된다.

```java
public String getName(Person this) {
    return this.name;
}
```

이제 `getName`은 순수 함수이다. 이것이 **파이썬에서 기본적으로 채택한 방법**이다. 파이썬에서, 모든 객체 메소드는 `this`를 첫번째 인자로 가진다. 그리고 그것을 `self`라고 부른다.

```python
def getName(self):
    self.name
```

분명히 **명시적인 것**이 묵시적인 것보다 낫다.

## 설계 결함의 징후(Design Smell)

기본 디자인 규칙을 위반하고 디자인 품질에 부정적인 영향을 주는 가능성을 포함하고 있는 것을 **Design Smell**이라고 한다.

가장 발견하기 쉬운 두가지 타겟이다.
1. **인자가 없는 함수**

항상 같은 값을 반환하거나 숨겨진 입력이 있다.
```java
public Int foo() {}
```
가령 이런 식이다.

<br>

2. **반환값이 없는 함수**

부작용이 있거나 호출해봤자 아무 의미 없는 함수이다.
```java
public void foo(...) {...}
```
함수 시그니처만 보면 해당 함수를 호출할 이유가 없다.

## 결론

모든 언어는 순수 함수를 작성할 수 있다.<br>
하지만 모든 언어가 함수형 프로그래밍 언어는 아니다.<br>

함수형 프로그래밍 언어는<br>
**1. 부작용 없는 프로그래밍을 장려하며 지원한다.**<br>
**2. 가능한 만큼 부작용을 제거하며, 그렇지 못할 경우에는 철저하게 통제하도록 적극적으로 돕다.**<br>
**3. 부작용에 적대적이다.**


부작용을 직관적으로 인식하는 것은 우리가 코드를 바라보는 시각에 충분히 영향을 준다. 개별 함수를 보는 것부터 시스템 아키텍쳐를 보는 눈까지, 모든 것이 바뀔 수 있다.

# Reference
[(번역) 어떤 프로그래밍 언어들이 함수형인가?](https://medium.com/@jooyunghan/%EC%96%B4%EB%96%A4-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EB%93%A4%EC%9D%B4-%ED%95%A8%EC%88%98%ED%98%95%EC%9D%B8%EA%B0%80-fec1e941c47f)

[위키피디아 - Design Smell](https://en.wikipedia.org/wiki/Design_smell)